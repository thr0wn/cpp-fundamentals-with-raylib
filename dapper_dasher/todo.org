#+title: todo
#+author: natan
#+STARTUP: indent
#+TODO: TODO DOING WAITING | DONE

* DONE 1. Remove services
Remove services to get a more event oriented api.
** DONE 1.1. key-value-repository -> database
Remove the repository

New Events:
#+begin_src cpp
  gameEmitter->emit({"database/set", any})
  gameEmitter->emit({"database/get", any})
  gameEmitter->emit({"database/unset", any})
#+end_src

** DONE 1.2. log-service -> log.h
Remove the service

New events:
#+begin_src cpp
  gameEmitter->emit({"log/info", string})
#+end_src

** DONE 1.3. tile-service -> tile.cc (with static draw method) -> texture-loader.cc
Remove service and create a new texture-loader

** DONE 1.4. game-service.cc -> game.cc -> game-state.cc
** DONE 1.4. game-service.cc -> game.cc -> game-state.cc
Remove the service

New events:
#+begin_src cpp
  gameEmitter->emit({"game/state", &GameState})
#+end_src
* WAITING 2. New Functional API
** 2.1. Old API
Mainly composed using Observer Pattern and Service Pattern.
#+begin_src c++
  gameEmitter->on("game/init", [this](Event event) { onInit(); });
  gameEmitter->on("game/start", [this](Event event) { onStart(); });
  gameEmitter->on("game/restart", [this](Event event) { onRestart(); });
  gameEmitter->on("game/update", [this](Event event) { onUpdate(); });
  gameEmitter->on("game/render", [this](Event event) { onRender(); });
  gameEmitter->on("game/stop", [this](Event event) { onStop(); });
  gameEmitter->on("game/deinit", [this](Event event) { onDeinit(); });
  gameEmitter->on("game/pause", [this](Event event) { onPause(); });
  gameEmitter->on("game/resume", [this](Event event) { onResume(); });
#+end_src
Service call:
#+begin_src c++
  gameService->isPaused();
#+end_src

** 2.2. New API more functional
Create a more functional api. One function per lifecycle/event,
#+begin_src c++
  useStart([] {
    "..."
      });
#+end_src

#+begin_src c++
  useState([](State state, function setState) {
    "..."
      });
#+end_src

#+begin_src c++
  useRender([]{
    useState([](State state, function setState) {
      "..."
        });
   })
#+end_src
* WAITING 3. Async pointer
** Descrition
Create a mechanism to keep pointers to instances using the event system or a dependency injection solution.

** Solution
Given classB depends on classA and that container instantiate at least classA.
At the container:
#+begin_src cpp
  ...
  AsyncPointer::register(objectOfClassA);
  ...
#+end_src
On classB:
#+begin_src cpp
  ...
  ClassA *objectOfClassA = AsyncPointer::get<ClassA>();
  ...
#+end_src
